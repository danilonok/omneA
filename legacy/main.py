from IPython.core.debugger import prompt
from llama_index.llms.ollama import Ollama
from llama_index.core.agent import ReActAgent
from llama_index.core.tools import FunctionTool
import datetime
import subprocess
import shlex
from llama_index.core import PromptTemplate
import re

from commands import Commands
from steps import steps_parser, Steps
from commands import commands_parser

from llama_index.core.workflow import (
    StartEvent,
    StopEvent,
    Workflow,
    step,
    Event,
    Context
)
from llama_index.utils.workflow import draw_all_possible_flows
from nltk.chat.zen import responses
from openinference.instrumentation.llama_index import LlamaIndexInstrumentor
from phoenix.otel import register
import json
tracer_provider = register(
  project_name="my-llm-app", # Default is 'default'
  endpoint="http://localhost:6006/v1/traces",
)
LlamaIndexInstrumentor().instrument(tracer_provider=tracer_provider)


llm = Ollama(model="llama3.1", base_url="https://aefd-109-86-225-99.ngrok-free.app",request_timeout=60.0)
print(type(datetime.datetime.now()))




def execute_cmd_command(command: str) -> str:
    """Execute CMD command on local machine. Returns stdout and stderr of executed command. If strings are empty, command is executed."""
    commands = shlex.split(command)
    print(commands)
    try:
        result = subprocess.run(commands, capture_output=True, text=True)
    except:
        return "Error during executing"
    return f'Result stdout: {result.stdout}\nResult error: {result.stderr}'


PLANNER_PROMPT_TMP = (
    "Given a user's query generate a numbered list with all necessary steps to fulfill user request using only Windows 11 CMD Console"
    "Output format: json, jspon"
    "Query:"
    "{query}"
)

PLANNER_PROMPT = PromptTemplate(PLANNER_PROMPT_TMP)

CMD_GENERATOR_PROMPT_TMP = (
    "Given numbered list of steps to execute query"
    "List"
    "{steps}"
    "Query:"
    "{query}"
    "Generate Windows 11 CMD Commands for each step."
    'Return all commands in json format. Json Schema: {commands:[{"command":"cd C:/"}]}'
)

CMD_GENERATOR_PROMPT = PromptTemplate(CMD_GENERATOR_PROMPT_TMP)

CMD_CHECKER_PROMPT_TMP = (
    "Given numbered list of generated Windows 11 CMD commands. In the prompt there could be some mistakes because they are generated by AI."
    "List"
    "{steps}"
    'Return all commands in json format. Json Schema: {commands:[{"command":"cd C:/"}]}'
)

CMD_CHECKER_PROMPT = PromptTemplate(CMD_CHECKER_PROMPT_TMP)

class StepsProduced(Event):
    steps: str

class PlannedEvent(Event):
    result: str

class CommandsGeneratedEvent(Event):
    result: str

class CMDWorkflow(Workflow):
    @step
    async def planner(self, ctx: Context, ev: StartEvent) -> PlannedEvent:
        await ctx.set('query', ev.query)

        response : Steps = steps_parser(query=ev.query)
        print(response)

        for step in response.steps:
            ctx.send_event(PlannedEvent(result=step.text))

    @step
    async def CMDGenerator(self, ctx: Context, ev: PlannedEvent) -> CommandsGeneratedEvent:

        response  = commands_parser(query=ctx.get('query'), step=ev.result)
        return StopEvent(result=str(response))

    @step
    async def CMDCommandExecutor(self, ctx: Context, ev: CommandsGeneratedEvent) -> StopEvent:
        pattern = r'\{(?:[^{}]|"(?:\\.|[^"])*"|\'(?:\\.|[^\'])*\'|\{(?:[^{}]|"(?:\\.|[^"])*")*\})*\}'

        match = re.findall(pattern, ev.result, re.DOTALL)
        print(match)

        if match:
            json_str = match[0]
            try:
                data = json.loads(json_str)
                print(data)
                for command in data['commands']:
                    execute_cmd_command(command['command'])
                return StopEvent(result=str('Commands executed successfully'))
            except json.JSONDecodeError:
                print("Invalid JSON")
                return StopEvent(result=str('Error parsing JSON'))

async def main():
    w = CMDWorkflow(timeout=40, verbose=True)
    result = await w.run(query='Summarize the contents of the last file I downloaded. Write the summary into the file summary.txt in folder C:/Work')
    print(result)
if __name__ == "__main__":
    import asyncio

    asyncio.run(main())